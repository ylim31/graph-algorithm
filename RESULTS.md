# Results
## Extracting and Processing Data
We originally converted the JSON into two CSV files, one with a list of nodes and one with its neighbor, and tried to read every line to initialize our graph. This process was very messy because we had to play with delimiters and strtok. Also, when the user creates the CSV files in a slightly wrong format, the program would still run with the incorrect data.
So in the end, we found a third party library that parses through the JSON. This was much easier because the library allowed us to iterate through the JSON object and its array very conveniently. The one setback was that it was pretty slow in iterating through very large datasets like LastFM, which took around ~30 seconds. However, we decided it was still much better than our previous method. For the target file, we knew that those target ids represent a physical location, but it never specifies where that location is. So we had to come up with a way to process this data and set the edge weights. We first converted the target id from the target file into a point in the coordinate graph. This coordinate graph has a width of 5 points and any integer greater will be on a higher y-axis. After mapping the target ids, the distance between two points will be the edge weight between those nodes with those target ids. We talk more about this in the presentation video as well. Overall, properly extracting the data was successful as long as you follow the format in README.md.


## BFS (Traversal)
BFS is a traversing algorithm where we start traversing from a source node and traverse the graph layerwise thus exploring the neighbour nodes that are directly connected to the source node. We then move towards the next-level neighbour nodes. We implemented the BFS traversal such that it doesn't get stuck in an inifinite loop when we input graphs which may contain cycles. To avoid visiting a node more than once (espescially during cycles), we used an unordered vertex-boolean map (is_visited_) which saved every vertex on the graph and the paired True/False value which signified if that vertex has been visited or not. We used a map instead of the custom rray or vector in order to keep our time complexity as O(1) and to extend our implimentation to graphs with their vertices as alphabets and symbols rather than just integers. We also added functionality to avoid missing out nodes which aren't connected to the node we begin traversing with (disconnected components). To make this possible, our function (connectedComp) ensures that all the nodes of the given graph are traversered using the Breadth First Search traversing algorithm. Here, the traversal function acts as a sub set of the connectedComp function. We used a vector of vectors to showcase the different components of the graph given. We tested our algorithm using 'baby tests' which were nothing but graphs of different types - simple graphs, graphs with cycles, graphs with disconnect components etc. Overall, the BFS implementation was a success.


## Dijkstra's Algorithm
Dijkstra was created using an adjacency list implemented graph. We created a bunch of unordered_maps to keep track of the data we need for Dijkstra. The is_visited map checks to make sure all the adjacent neighbor nodes we are adding to the priority_queue is not visited. Because priority_queue allows duplicates nodes to be added, is_marked does the same thing where it checks if the node should be added into the priority queue. This makes it so that a node is inserted into the priority_queue only once. The shortest_distance map keeps track of the shortest cost (sum of all weights) from the start node to every other node in the graph. As the algorithm runs, it checks whether the current shortest distance is bigger or smaller than the new shortest distance. When we determine a new shortest distance, we set the node to get to that current node in the prev_vertex. This way at the end, we can backtrack through the prev_vertex to find the shortest path. The algorithm works pretty well from many different test cases we wrote. When we first started Dijkstra, we didn't use priority_queue to store the nodes. So finding the smallest distance took 0(n) because we had to iterate the stored nodes. This made the algorithm even slower and changing to priority_queue where it sorts the nodes from smallest to largest when it stores log(n) time. Still, for big datasets like LastFM, it takes around 10 seconds to load and we believe it's because we are trying to access data from a bunch of maps we created every loop. However, the advantage of using a map is that the graph can store any characters, such as letters and symbols, rather than just boring numbers. We tested using letters using dijkstra_baby_test3.json and dijkstra_baby_target3.csv in our tests/part1.cpp. Overall, the Dijkstra implementation was a success.


### Land Mark Implementation
The Landmark implementation aims to find the shortest path between two nodes under one condition. It has to visited specified nodes during its journey. As we have already implemented Dijkstra's alogorithm, it was natural to use our Dijkstra's algorithm within our landmark implementation. In simple terms, we use two vectors: one that includes the landmark nodes and one that will return the final path. We iterated through the landmarks in the first vector applying Dijkstra's algorithm every interval we needed to satisfy. Compared to our manual calculations for smaller scaled tests, our landmark algorithm has returned our expected results for every test. One important discovery we have made is the permutation of the landmarks vector. For example, if we gave a landmarks vector of <1,2,3>. Due to the fact we iterate through this vector in order, the algorithm assumes we have to visit 1, 2, 3, in that specific order. However, this is not the case. So, we run this enitre algorithm on every possible permutation of this vector, checking <1,3,2> <2,1,3> <2,3,1> <3,1,2> <3,2,1>. Thus, the path with the smallest total edge weight is the path we return. Overall, the Land Mark implementation was a success.


### Basic User Input
We also wrote some basic user input to display our algorithm. You can read the README.md for specific instructions. Basically, the user can write command lines that we will take and build the algorithm chosen. The first argument is the name of the algorithm, the second argument is the path file to JSON, and the third argument is the path file to the target file. Once run, the terminal will prompt the user to enter vertices (depending on the algorithm). If the vertices user inputs are not in the graph, it will print: `You entered an invalid vertex`. This was a fun way to show our algorithms aside from our test cases and it allows the user to play with it. Note that everything is coded manually so it's easy to break it if you come with malicious intent. So please try not to.
